# -*- coding: utf-8 -*-
"""12_CS4501_BuildingArchetype.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zj3N1i_goc8aWlEa-3EeklnrzHUhAaqL
"""

# Commented out IPython magic to ensure Python compatibility.
load_ext autoreload
# %autoreload 2
# %matplotlib inline

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

import os

from sklearn.tree import plot_tree

from sklearn.preprocessing import LabelEncoder

from sklearn.tree import DecisionTreeClassifier
from sklearn.tree import DecisionTreeRegressor

from sklearn.ensemble import RandomForestClassifier

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score

from sklearn.impute import SimpleImputer

from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import OneHotEncoder

"""<h2>Create DataFrames for Building Archetypes</h2>

<p>Table B.10 from "A data-driven approach to optimize urban scale energy retrofit decisions for residential buildings" by Usman, Ali, et.al has been used as inspiration.  New tables were developed from the whole BER dataset split per EnergyRating category per unique building archetypes found in the dataset.</p>

 <p>Here are the tables for each of the unique dwelling types in the dataset, containing the mean values of the different UValues.</p>
"""

if 'google.colab' in str(get_ipython()):
  from google.colab import drive
  drive.mount("/content/drive", force_remount=True)
  base_dir = "./drive/My Drive/Colab Notebooks/" # You may need to change this, depending on where your notebooks are on Google Drive
else:
  base_dir = "/content/drive/My Drive/Colab Notebooks/" # You may need to change this, depending on where your datasets folder is
dataset_dir = os.path.join(base_dir, "Datasets/Ber_Archetype_Mean.csv")  # Assuming the file is a CSV

print(os.listdir(base_dir + "Datasets/"))  # This will list all files in the Datasets directory

# Load the dataset
print(dataset_dir)
archetype_df = pd.read_csv(dataset_dir)

# Shuffle the dataset
archetype_df = archetype_df.sample(frac=1, random_state=2)
archetype_df.reset_index(drop=True, inplace=True)

# "archetype_df"is the DataFrame containing the DwellingTypeDescr column
unique_dwelling_types = archetype_df['DwellingType'].unique()

# Print the list of unique dwelling types
print(unique_dwelling_types)

archetype_df.shape

archetype_df.columns

archetype_df.dtypes

# Examining the columns, their datatypes and whether there are nulls
archetype_df.info()

# Set option to display all columns
pd.set_option('display.max_columns', None)

# Look at the first 20 rows
archetype_df.head(20)

# Summary statistics
archetype_df.describe(include="all")

# Define the columns for which we want to plot the distribution and mean
columns = ["BerRatingMean", "UValueWallMean", "UValueRoofMean", "UValueFloorMean", "UValueWindowMean", "UValueDoorMean", "CO2RatingMean", "HSMainSystemEfficiencyMean"]

# Create a single figure with multiple subplots
fig, axes = plt.subplots(2, 4, figsize=(20, 12))  # 2 rows, 4 plots per row

# Loop through each column and create a plot on respective axes
for i, column in enumerate(columns):
    # Calculate row and column for current subplot
    row, col = divmod(i, 4)

    # Plot the histogram on the subplot at [row, col]
    axes[row, col].hist(archetype_df[column], bins=20, color='blue', edgecolor='black')

    # Draw a vertical line for the mean
    axes[row, col].axvline(archetype_df[column].mean(), color='red', linestyle='dashed', linewidth=2)

    # Annotate the mean value on the subplot
    axes[row, col].text(archetype_df[column].mean(), axes[row, col].get_ylim()[1], f'Mean: {archetype_df[column].mean():.2f}', color='red', ha="right", va="center")

    # Set the title, and the x and y labels for the subplot
    axes[row, col].set_title(column)
    axes[row, col].set_xlabel(column)
    axes[row, col].set_ylabel('Frequency')

# If there are less than 8 columns to plot, the remaining subplot(s) will be hidden
for j in range(i + 1, 8):  # 8 because 2 rows * 4 columns = 8 plots
    row, col = divmod(j, 4)
    fig.delaxes(axes[row][col])  # Remove empty subplot

# Adjust the layout so there's no overlap
plt.tight_layout()

# Display the plots
plt.show()

# Set up the plotting area
fig, axes = plt.subplots(3, 3, figsize=(14, 10))  # Create a figure and a 3x3 grid of subplots
fig.suptitle("BerRatingMean vs Other Mean Values")  # Title for the whole figure

# BerRatingMean vs UValueWallMean
axes[0, 0].scatter(archetype_df["BerRatingMean"], archetype_df["UValueWallMean"], alpha=0.8)
axes[0, 0].set_title("BerRatingMean vs UValueWallMean")
axes[0, 0].set_xlabel("BerRatingMean")
axes[0, 0].set_ylabel("UValueWallMean")

# BerRatingMean vs UValueRoofMean
axes[0, 1].scatter(archetype_df["BerRatingMean"], archetype_df["UValueRoofMean"], alpha=0.8)
axes[0, 1].set_title("BerRatingMean vs UValueRoofMean")
axes[0, 1].set_xlabel("BerRatingMean")
axes[0, 1].set_ylabel("UValueRoofMean")

# BerRatingMean vs UValueFloorMean
axes[0, 2].scatter(archetype_df["BerRatingMean"], archetype_df["UValueFloorMean"], alpha=0.8)
axes[0, 2].set_title("BerRatingMean vs UValueFloorMean")
axes[0, 2].set_xlabel("BerRatingMean")
axes[0, 2].set_ylabel("UValueFloorMean")

# BerRatingMean vs UValueWindowMean
axes[1, 0].scatter(archetype_df["BerRatingMean"], archetype_df["UValueWindowMean"], alpha=0.8)
axes[1, 0].set_title("BerRatingMean vs UValueWindowMean")
axes[1, 0].set_xlabel("BerRatingMean")
axes[1, 0].set_ylabel("UValueWindowMean")

# BerRatingMean vs UValueDoorMean
axes[1, 1].scatter(archetype_df["BerRatingMean"], archetype_df["UValueDoorMean"], alpha=0.8)
axes[1, 1].set_title("BerRatingMean vs UValueDoorMean")
axes[1, 1].set_xlabel("BerRatingMean")
axes[1, 1].set_ylabel("UValueDoorMean")

# BerRatingMean vs CO2RatingMean
axes[1, 2].scatter(archetype_df["BerRatingMean"], archetype_df["CO2RatingMean"], alpha=0.8)
axes[1, 2].set_title("BerRatingMean vs CO2RatingMean")
axes[1, 2].set_xlabel("BerRatingMean")
axes[1, 2].set_ylabel("CO2RatingMean")

# BerRatingMean vs HSMainSystemEfficiencyMean
axes[2, 0].scatter(archetype_df["BerRatingMean"], archetype_df["HSMainSystemEfficiencyMean"], alpha=0.8)
axes[2, 0].set_title("BerRatingMean vs HSMainSystemEfficiencyMean")
axes[2, 0].set_xlabel("BerRatingMean")
axes[2, 0].set_ylabel("HSMainSystemEfficiencyMean")

# Hide the last two subplots
fig.delaxes(axes[2,1])
fig.delaxes(axes[2,2])

# Adjust layout for better spacing between plots
plt.tight_layout()
plt.subplots_adjust(top=0.9)  # Adjust the top margin so the suptitle doesn't overlap with the plots

# Show the plots
plt.show()

#'features' list contains the names of all columns in a dataset related to criminal records and rehabilitation
archetype_features = ["DwellingType", "EnergyRating", "BerRatingMean", "UValueWallMean", "UValueRoofMean",
            "UValueFloorMean", "UValueWindowMean", "UValueDoorMean", "CO2RatingMean", "HSMainSystemEfficiencyMean"]

# 'numeric_features' list contains names of columns with numerical data
archetype_numeric_features = ["BerRatingMean", "UValueWallMean", "UValueRoofMean",
            "UValueFloorMean", "UValueWindowMean", "UValueDoorMean", "CO2RatingMean", "HSMainSystemEfficiencyMean"]

# 'nominal_features' list contains names of columns with objects/strings
archetype_nominal_features = ["DwellingType", "EnergyRating"]

# Save the preprocessed archetype dataframe to a new CSV file
archetype_df.to_csv('/content/drive/My Drive/Colab Notebooks/Datasets/Processed_Ber_Archetype_Mean_2.csv', index=False)

# Load the saved lookup table
# archetype_transformed_df = pd.read_csv('/content/drive/My Drive/Colab Notebooks/Datasets/Processed_Ber_Archetype_Mean.csv')